//#pragma once
//
//#include "svm_instructions.h"
//
//#include <iostream>
//#include <string>
//#include <vector>
//#include <unordered_map>
//
//class svmassembler {
//private:
//	std::string text;
//	int index;
//	char cur;
//	bool haserror = false;
//
//	bool hasnext() {
//		return index + 1 < (int)text.size();
//	}
//
//	void getnext() {
//		if (!hasnext()) {
//			cur = '\0';
//		}
//		else {
//			cur = text.at(++index);
//		}
//	}
//
//	uint8_t translatemnemonic(std::string mnemonic) {
//		if (mnemonics.find(mnemonic) == mnemonics.end()) {
//			haserror = true;
//			std::cout << "mnemonic not found: " + mnemonic << std::endl;
//			return -1;
//		}
//		return mnemonics.at(mnemonic);
//	}
//
//	uint64_t findlabel(std::string label) {
//		if (labels.find(label) == labels.end()) {
//			haserror = true;
//			std::cout << "label not found: " + label << std::endl;
//			return -1;
//		}
//		return labels.at(label);
//	}
//
//public:
//	svmassembler(std::string text) {
//		this->text = text;
//		this->index = -1;
//		getnext();
//	}
//
//	std::vector<uint8_t> getbytecode() {
//		std::vector<uint8_t> bytecode;
//		std::cout << "generating bytecode..." << std::endl;
//
//		while (cur != '\0') {
//			if (isspace(cur)) { // skip whitespace
//				getnext();
//			}
//			else if (isalpha(cur)) { // get mnemonic
//				std::string operation = "";
//
//				while (isalnum(cur) || cur == '_') {
//					operation += cur;
//					getnext();
//				}
//
//				if (operation.size() > 0 && operation.at(operation.size() - 1) == '_') {
//					bytecode.push_back(nop); // byte corresponding to a label
//					labels.insert({operation.substr(operation.size()), bytecode.size()});
//					continue;
//				}
//
//				uint8_t byte = translatemnemonic(operation);
//				bytecode.push_back(byte);
//			}
//			else if (isdigit(cur) || cur == '-' || cur == '+') { // get a number as double and store it as bytecode
//				std::string number;
//				int numdots = 0;
//				if (cur == '+' || cur == '-') {
//					number += cur;
//					getnext();
//				}
//
//				while (isdigit(cur) || cur == '.') {
//					if (cur == '.') {
//						if (numdots == 1) {
//							break;
//						}
//						numdots++;
//					}
//					number += cur;
//					getnext();
//				}
//
//				double value = std::stod(number);
//				// std::cout << "number is: " << value << std::endl;
//
//				uint8_t* doubleasbytes = (uint8_t*)&(value);
//				
//				for (int i = 0; i < 8; i++) {
//					bytecode.push_back(doubleasbytes[i]);
//				}
//
//				// std::cout << "number is: " << *(double*) doubleasbytes << std::endl;
//			}
//			else if (cur == '"') { // get a string and store it as bytecode
//				getnext();
//
//				while (cur != '"') {
//					bytecode.push_back((uint8_t) cur);
//					getnext();
//				}
//				getnext();
//
//			}
//			else if (cur == '\'') { // encode char in bytecode
//				getnext();
//
//				bytecode.push_back((uint8_t) cur);
//				getnext();
//				if (cur != '\'') {
//					haserror = true;
//					std::cout << "unterminated single quote" << std::endl;
//				}
//				getnext();
//			}
//			else {
//				haserror = true;
//				std::cout << "svm assembler error: invalid syntax." << std::endl;
//			}
//		}
//
//		if (haserror) {
//			std::cout << "failed to generate bytecode." << std::endl;
//		}
//		else {
//			std::cout << "successfully generated bytecode" << std::endl;
//		}
//
//		return bytecode;
//	}
//};
//
//
#pragma once
//
//#include "svm_instructions.h"
//
//#include <iostream>
//#include <string>
//#include <vector>
//#include <unordered_map>
//
//class svmassembler {
//private:
//	std::string text;
//	int index;
//	char cur;
//	bool haserror = false;
//
//	bool hasnext() {
//		return index + 1 < (int)text.size();
//	}
//
//	void getnext() {
//		if (!hasnext()) {
//			cur = '\0';
//		}
//		else {
//			cur = text.at(++index);
//		}
//	}
//
//	uint8_t translatemnemonic(std::string mnemonic) {
//		if (mnemonics.find(mnemonic) == mnemonics.end()) {
//			haserror = true;
//			std::cout << "mnemonic not found: " + mnemonic << std::endl;
//			return -1;
//		}
//		return mnemonics.at(mnemonic);
//	}
//
//	uint64_t findlabel(std::string label) {
//		if (labels.find(label) == labels.end()) {
//			haserror = true;
//			std::cout << "label not found: " + label << std::endl;
//			return -1;
//		}
//		return labels.at(label);
//	}
//
//public:
//	svmassembler(std::string text) {
//		this->text = text;
//		this->index = -1;
//		getnext();
//	}
//
//	std::vector<uint8_t> getbytecode() {
//		std::vector<uint8_t> bytecode;
//		std::cout << "generating bytecode..." << std::endl;
//
//		while (cur != '\0') {
//			if (isspace(cur)) { // skip whitespace
//				getnext();
//			}
//			else if (isalpha(cur)) { // get mnemonic
//				std::string operation = "";
//
//				while (isalnum(cur) || cur == '_') {
//					operation += cur;
//					getnext();
//				}
//
//				if (operation.size() > 0 && operation.at(operation.size() - 1) == '_') {
//					bytecode.push_back(nop); // byte corresponding to a label
//					labels.insert({operation.substr(operation.size()), bytecode.size()});
//					continue;
//				}
//
//				uint8_t byte = translatemnemonic(operation);
//				bytecode.push_back(byte);
//			}
//			else if (isdigit(cur) || cur == '-' || cur == '+') { // get a number as double and store it as bytecode
//				std::string number;
//				int numdots = 0;
//				if (cur == '+' || cur == '-') {
//					number += cur;
//					getnext();
//				}
//
//				while (isdigit(cur) || cur == '.') {
//					if (cur == '.') {
//						if (numdots == 1) {
//							break;
//						}
//						numdots++;
//					}
//					number += cur;
//					getnext();
//				}
//
//				double value = std::stod(number);
//				// std::cout << "number is: " << value << std::endl;
//
//				uint8_t* doubleasbytes = (uint8_t*)&(value);
//				
//				for (int i = 0; i < 8; i++) {
//					bytecode.push_back(doubleasbytes[i]);
//				}
//
//				// std::cout << "number is: " << *(double*) doubleasbytes << std::endl;
//			}
//			else if (cur == '"') { // get a string and store it as bytecode
//				getnext();
//
//				while (cur != '"') {
//					bytecode.push_back((uint8_t) cur);
//					getnext();
//				}
//				getnext();
//
//			}
//			else if (cur == '\'') { // encode char in bytecode
//				getnext();
//
//				bytecode.push_back((uint8_t) cur);
//				getnext();
//				if (cur != '\'') {
//					haserror = true;
//					std::cout << "unterminated single quote" << std::endl;
//				}
//				getnext();
//			}
//			else {
//				haserror = true;
//				std::cout << "svm assembler error: invalid syntax." << std::endl;
//			}
//		}
//
//		if (haserror) {
//			std::cout << "failed to generate bytecode." << std::endl;
//		}
//		else {
//			std::cout << "successfully generated bytecode" << std::endl;
//		}
//
//		return bytecode;
//	}
//};
//
//
