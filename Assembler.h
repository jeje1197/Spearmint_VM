#pragma once

#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>

#include "svm_instructions.h"
#include "AsmToken.h"

using std::string;
using std::vector;

class SvmAssembler {
private:
	string text;
	int index;
	char cur;
	bool haserror = false;

	bool hasnext() {
		return index + 1 < (int)text.size();
	}

	void getnext() {
		if (!hasnext()) {
			cur = '\0';
		}
		else {
			cur = text.at(++index);
		}
	}

public:
	SvmAssembler(string text) {
		this->text = text;
		this->index = -1;
		getnext();
	}

	vector<AsmToken> getTokens() {
		vector<AsmToken> tokens;

		while (cur != '\0') {
			if (isspace(cur)) { // skip whitespace
				getnext();
			}
			else if (isalpha(cur)) { // scan instructions
				string operation = "";

				while (isalnum(cur) || cur == '_') {
					operation += cur;
					getnext();
				}

				AsmToken token;
				token.type = ASM_INSTRUCTION;
				token.value.string = &operation;
				tokens.push_back(token);
			}
			else if (cur == '$') { // scan identifier
				getnext();
				string operation = "";

				while (isalnum(cur) || cur == '_') {
					operation += cur;
					getnext();
				}

				AsmToken token;
				token.type = ASM_IDENTIFIER;
				token.value.string = &operation;
				tokens.push_back(token);
			}
			else if (isdigit(cur) || cur == '-' || cur == '+') { // get a number as double and store it as bytecode
				string number;
				int numdots = 0;
				if (cur == '+' || cur == '-') {
					number += cur;
					getnext();
				}

				while (isdigit(cur) || cur == '.') {
					if (cur == '.') {
						if (numdots == 1) {
							break;
						}
						numdots++;
					}
					number += cur;
					getnext();
				}

				AsmToken token;
				token.type = ASM_NUMBER;
				token.value.value = std::stod(number);
			}
			else if (cur == '"') { // get a string and store it
				getnext();

				string str_value;
				while (cur != '"') {
					str_value += cur;
					getnext();
				}
				getnext();

				AsmToken token;
				token.type = ASM_STRING;
				token.value.string = &str_value;

				tokens.push_back(token);
			}
			else {
				haserror = true;
				std::cout << "svm assembler error: invalid syntax." << std::endl;
			}
		}

		if (haserror) {
			std::cout << "failed to generate bytecode." << std::endl;
		}
		else {
			std::cout << "successfully generated bytecode" << std::endl;
		}

		return tokens;
	}
};

